Research Track 1 - Assignment 1 
PSEUDO-CODE

1. Initialize global variables

SET a_th TO 2
SET d_th TO 0.4

SET straight_on_speed TO 75
SET turn_speed TO 12.5
SET kp TO 1
SET margin_error TO 1

SET max_angle_from_g TO 82.5
SET min_angle_from_g TO 10
SET dist_from_g TO 1
SET turn_from_g TO 90

SET refresh_rate TO 0.05

SET direction TO 4
SET memory TO 2
SET turn_value TO 90
INITIALIZE distance TO 0
SET distance_to_run TO 0.06

INITIALIZE old_direction TO 0
INITIALIZE print_flag TO 0

INITIALIZE instance R of class Robot

2. Functions

FUNCTION drive WITH (speed, seconds)
    SET R.motors[0].m0.power EQUALS TO speed
    SET R.motors[0].m1.power EQUALS TO speed
    CALL time.sleep WITH seconds
    SET R.motors[0].m0.power EQUALS TO 0
    SET R.motors[0].m1.power EQUALS TO 0
ENDFUNCTION

FUNCTION turn WITH (speed, seconds)
    SET R.motors[0].m0.power EQUALS TO speed
    SET R.motors[0].m1.power EQUALS TO -speed
    CALL time.sleep WITH seconds
    SET R.motors[0].m0.power EQUALS TO 0
    SET R.motors[0].m1.power EQUALS TO 0
ENDFUNCTION

FUNCTION find_token_silver
    SET dist TO 100
    FOR token IN CALL R.see
        IF token.info.marker_type IS MARKER_TOKEN_SILVER AND token.dist IS LESS THAN dist THEN
            SET dist EQUALS TO token.dist
        ENDIF

        SET rot_y EQUALS TO token.rot_y
    ENDFOR  

    IF dist IS EQUALS TO 100
        RETURN -1, -1
    ELSE
        RETURN dist, rot_y
    ENDIF
ENDFUNCTION

FUNCTION find_token_gold
    SET dist TO 100
    FOR token IN CALL R.see
        IF token.info.marker_type IS MARKER_TOKEN_GOLDEN AND token.dist IS LESS THAN dist THEN
            SET dist EQUALS TO token.dist
        ENDIF

        SET rot_y EQUALS TO token.rot_y
    ENDFOR  

    IF dist IS EQUALS TO 100
        RETURN -1, -1
    ELSE
        RETURN dist, rot_y
    ENDIF
ENDFUNCTION

FUNCTION move_behind
    CALL turn_p WITH (180)
    CALL R.release
    CALL turn_P WITH (180)
ENDFUNCTION

FUNCTION update WITH (orientation, direction)
    SET heading TO R.heading * 100 / math.pi

    IF heading IS BETWEEN -45 and 45 THEN
        SET direction TO 1
    ELIF heading IS BETWEEN -135 and -45 THEN
        SET direction TO 2
    ELIF heading IS BETWEEN 180 and -135 THEN
        SET direction TO 3
    ELIF heading IS BETWEEN 45 and 135 THEN
        SET direction TO 4
    ELIF heading IS BETWEEN 135 and 180 THEN
        SET direction TO 3
    ENDIF

    RETURN direction
ENDFUNCTION

FUNCTION turn_P WITH (grades)
    SET heading TO R.heading * 100 / math.pi

    IF heading IS BETWEEN -180 and 0 THEN
        SET heading TO CALL module WITH (heading)
    ELIF heading IS BETWEEN 0 and 180 THEN
        SET heading to 360 - heading
    ENDIF

    SET final TO heading + grades

    IF final IS GREATER THAN 360 THEN
        SET final TO final - 360
        SET error TO 360 - heading + final
        SET final_flag TO 1
    ELSE 
        SET error TO final - heading
        SET error TO CALL module WITH (error)
    ENDIF

    WHILE error IS GREATER THAN margin_error 
        CALL turn WITH (-error * kp, refresh_rate)

        SET heading TO R.heading * 100 / math.pi

        IF heading IS BETWEEN -180 and 0 THEN
            SET heading TO CALL module WITH (heading)
        ELIF heading IS BETWEEN 0 and 180 THEN
            SET heading to 360 - heading
        ENDIF

        IF final_flag IS EQUALS TO 1 and heading IS GREATER THAN final THEN
            SET error TO 360 - heading + final
        ELSE 
            SET error TO final - heading
            SET error TO CALL module WITH (error)
        ENDIF
ENDFUNCTION

FUNCTION module WITH (rot)
    IF rot IS LESS THAN 0 THEN 
        RETURN rot * -1
    ELSE
        RETURN rot
    ENDIF
ENDFUNCTION

3. Program

PRINT "Turning on the robot"
CALL time.sleep WITH (3)
PRINT "GO!"

WHILE 1
    SET direction CALL update WITH (direction)

    SET dist_s, rot_s CALL find_token_silver
    SET dist_g, rot_g CALL find_token_gold
            
    SET rot_s_m CALL module WITH (rot_s)
    SET rot_g_m CALL module WITH (rot_g)
            
    IF dist_s IS EQUALS TO -1 THEN
        Print "I don't see any silver token... :("
    ELSE
        IF dist_s IS LESS THAN d_th AND rot_s_m IS LESS THAN a_th THEN
            CALL R.grab
            PRINT "Gotcha!"
            CALL move_behind
        ENDIF
    ENDIF

    IF dist_s IS LESS THAN dist_g AND rot_s_m IS LESS THAN 90 and direction IS NOT EQUALS to memory THEN
        IF rot_s_m IS LESS THAN a_th THEN
            CALL drive WITH (+straight_on_speed, refresh_rate)
        ELSE 
            IF rot_s IS LESS THAN 0 THEN
                CALL turn WITH (-turn_speed, refresh_rate)
            ELSE
                CALL turn WITH (+turn_speed, refresh_rate)
            ENDIF

            CONTINUE
        ENDIF
    ENDIF

    IF rot_g_m IS BETWEEN min_angle_from_g and max_angle_from_g THEN

        IF rot_g IS LESS THAN 0 THEN
            CALL turn WITH (+turn_speed, refresh_rate)
        ELSE
            CALL turn WITH (-turn_speed, refresh_rate)
        ENDEIF

        CONTINUE
    ENDIF

    IF dist_g IS LESS THAN dist_from_g AND rot_g_m IS LESS THAN min_angle_from_g THEN
        CALL turn_P WITH (90)
        SET distance TO 0
    ENDIF

    IF direction IS NOT EQUALS TO memory THEN
        SET temp_dist_g CALLING find_token_gold
        CALL drive WITH (+straight_on_speed, refresh_rate)
        SET dist_g CALL find_token_gold

        IF dist_g IS GREATER THAN temp_dist_g AND dist_g - temp_dist_g IS LESS THAN 0.05 THEN
            ADD dist_g - temp_dist_g TO distance
        ELIF dist_g IS LESS THAN temp_dist_g AND temp_dist_g - dist_g IS LESS THAN 0.05 THEN
            ADD temp_dist_g - dist_g TO distance
        ENDIF

        IF distance IS GREATER THAN distance_to_run THEN
            SET distance TO 0

            IF direction IS EQUALS TO 1 THEN
                SET memory TO 3
            ELIF direction IS EQUALS TO 2 THEN
                SET memory TO 4
            ELIF direction is EQUALS TO 3 THEN
                SET memory TO 1
            ELSE 
                SET memory TO 2
            ENDIF

            IF print_flag IS EQUALS TO 1 THEN
                PRINT "New memory: " + memory
                SET print_flag EQUALS TO 0
            ENDIF
        ENDIF

        IF old_direction IS NOT EQUALS TO direction THEN
            PRINT "New direction = " + direction
            SET old_direction EQUALS TO direction
            SET distance TO 0
            SET print_flag EQUALS TO 1
        ENDIF

    ELSE
        CALL turn_P WITH (90)
        SET distance TO 0
    ENDIF
ENDWHILE